#!/bin/bash
set -e

# PromptStash CLI
# A simple CLI for managing your PromptStash installation

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Determine the installation directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INSTALL_DIR="$(dirname "$SCRIPT_DIR")"
VERSION_FILE="$INSTALL_DIR/.version"
REPO_URL="https://github.com/korotkevics/promptstash.git"
GITHUB_API_URL="https://api.github.com/repos/korotkevics/promptstash/releases/latest"

# Check for updates (unless disabled)
check_for_updates() {
    # Skip if update check is disabled
    if [ "${PROMPTSTASH_NO_UPDATE_CHECK}" = "1" ]; then
        return 0
    fi
    
    # Skip if we checked recently (within last 24 hours)
    local cache_file="$HOME/.promptstash_update_check"
    if [ -f "$cache_file" ]; then
        local last_check=$(cat "$cache_file" 2>/dev/null)

        # Validate that last_check is a number
        if [[ "$last_check" =~ ^[0-9]+$ ]]; then
            local current_time=$(date +%s)
            local time_diff=$((current_time - last_check))

            # 86400 seconds = 24 hours
            if [ $time_diff -lt 86400 ]; then
                return 0
            fi
        else
            # Corrupted cache file, remove it
            rm -f "$cache_file"
        fi
    fi
    
    # Get local version
    if [ ! -f "$VERSION_FILE" ]; then
        return 0
    fi
    local local_version=$(cat "$VERSION_FILE")
    
    # Get latest release version from GitHub API
    local latest_version=""
    local api_response=""

    if command -v curl &> /dev/null; then
        api_response=$(curl -sf --max-time 5 "$GITHUB_API_URL" 2>/dev/null)
    elif command -v wget &> /dev/null; then
        api_response=$(wget -qO- --timeout=5 "$GITHUB_API_URL" 2>/dev/null)
    fi

    # Only proceed if we got a valid response
    if [ -n "$api_response" ] && echo "$api_response" | grep -q '"tag_name"'; then
        if command -v jq &> /dev/null; then
            # Use jq for robust JSON parsing
            latest_version=$(echo "$api_response" | jq -r '.tag_name // empty' 2>/dev/null | sed 's/^v//')
        else
            # Fallback to grep/sed if jq is not available
            latest_version=$(echo "$api_response" | grep -o '"tag_name": *"[^"]*"' | sed 's/"tag_name": *"v*\([^"]*\)"/\1/')
        fi
    fi
    
    # Update cache file
    date +%s > "$cache_file"

    # Compare versions using semantic versioning
    if [ -n "$latest_version" ] && [ "$latest_version" != "$local_version" ]; then
        # Use sort -V for proper semantic version comparison (with fallback for older systems)
        local higher_version=""
        if printf "%s\n%s" "1.0.0" "1.0.1" | sort -V &>/dev/null; then
            higher_version=$(printf "%s\n%s" "$local_version" "$latest_version" | sort -V | tail -1)
        else
            # Fallback: simple string comparison (works for most semantic versions)
            if [ "$latest_version" \> "$local_version" ]; then
                higher_version="$latest_version"
            else
                higher_version="$local_version"
            fi
        fi

        if [ "$higher_version" = "$latest_version" ]; then
            echo -e "${YELLOW}⚡ A new version of promptstash is available (v$latest_version). Run 'promptstash self-update' to upgrade.${NC}"
            echo -e "${YELLOW}   Release notes: https://github.com/korotkevics/promptstash/releases/tag/v$latest_version${NC}"
            echo ""
        fi
    fi
}

# Self-update command
self_update() {
    echo -e "${BLUE}Updating PromptStash...${NC}"
    
    if [ ! -d "$INSTALL_DIR/.git" ]; then
        echo -e "${RED}✗ Error: Not a git repository${NC}"
        echo "Please reinstall PromptStash using the install script."
        exit 1
    fi
    
    cd "$INSTALL_DIR"

    # Restore alien files that were deleted by cleanup
    # This prevents deleted alien files from blocking self-update
    local alien_files=(
        "tests"
        ".github"
        ".benchmark"
        "scripts"
        "CODE_OF_CONDUCT.md"
        "CONTRIBUTING.md"
        ".gitignore"
    )

    for file in "${alien_files[@]}"; do
        if [ ! -e "$file" ] && git ls-files --error-unmatch "$file" &>/dev/null; then
            git checkout HEAD -- "$file" 2>/dev/null || true
        fi
    done

    # Check if there are uncommitted changes (excluding generated files)
    #
    # NOTE: These files are auto-generated by scripts during the lifecycle:
    # - .benchmark/data.json (by scripts/benchmark.py)
    # - README.md (benchmark section updated by scripts/benchmark.py)
    # - static/prompt-graph.svg (by scripts/generate_graph.py)
    # - static/prompt-graph.dot (by scripts/generate_graph.py)
    #
    # We exclude them from the uncommitted changes check to allow self-update
    # even when users have run benchmarking scripts locally.
    #
    # Alternative approach: Add these files to .gitignore, but that would prevent
    # CI from committing them automatically. The current approach allows CI to
    # manage these files while not blocking user updates.
    if ! git diff-index --quiet HEAD -- ':!.benchmark/' ':!README.md' ':!static/prompt-graph.svg' ':!static/prompt-graph.dot' 2>/dev/null; then
        echo -e "${RED}✗ Error: You have uncommitted changes${NC}"
        echo "Please commit or discard your changes before updating."
        echo "Run 'git status' in $INSTALL_DIR to see your changes."
        exit 1
    fi
    
    # Fetch and pull latest changes
    echo "Fetching latest changes..."
    git fetch --tags origin

    local before_version=$(cat "$VERSION_FILE" 2>/dev/null || echo "unknown")

    # Check current branch and switch to main if needed
    local current_branch=$(git branch --show-current)
    if [ "$current_branch" != "main" ]; then
        echo "Switching from branch '$current_branch' to 'main'..."
        git checkout main
    fi

    git pull origin main
    
    local after_version=$(cat "$VERSION_FILE" 2>/dev/null || echo "unknown")
    
    # Make sure the CLI is executable
    if [ -f "$INSTALL_DIR/bin/promptstash" ]; then
        chmod +x "$INSTALL_DIR/bin/promptstash"
    fi
    
    # Clear update check cache
    rm -f "$HOME/.promptstash_update_check"

    echo ""
    if [ "$before_version" = "$after_version" ]; then
        echo -e "${GREEN}✓ You are already on the latest version ($after_version)${NC}"
    else
        echo -e "${GREEN}✓ Successfully updated from v$before_version to v$after_version${NC}"
    fi

    # Run cleanup to remove unnecessary files
    echo ""
    check_alien_files
}

# Show version
show_version() {
    if [ -f "$VERSION_FILE" ]; then
        local version=$(cat "$VERSION_FILE")
        echo "PromptStash v$version"
    else
        echo "PromptStash (version unknown)"
    fi
}

# Check for alien files (files not needed in user installations)
check_alien_files() {
    local config_file="$HOME/.promptstash_cleanup_pref"

    # Check if user said "never ask again"
    if [ -f "$config_file" ]; then
        local pref=$(cat "$config_file" 2>/dev/null)
        if [ "$pref" = "never" ]; then
            return 0
        fi
    fi

    # Define essential files/directories that users need
    # Everything else is considered "alien" and can be removed
    local essential_patterns=(
        ".promptstash"     # The actual prompts
        "bin"              # CLI executable
        ".git"             # Git repository (for updates)
        ".gitignore"       # Git ignore patterns
        ".version"         # Version file
        "LICENSE"          # Legal requirement
        "README.md"        # Documentation
        "install.sh"       # Installation script
        "docs"             # Documentation directory
        "static"           # Static assets (logo, etc.)
        ".context"         # User context files
    )

    local found_aliens=()

    # Check all top-level files/directories
    for item in "$INSTALL_DIR"/{*,.[!.]*}; do
        # Skip if doesn't exist (glob didn't match)
        [ -e "$item" ] || continue

        local basename=$(basename "$item")
        local is_essential=false

        # Check if this item is essential
        for essential in "${essential_patterns[@]}"; do
            if [ "$basename" = "$essential" ]; then
                is_essential=true
                break
            fi
        done

        # If not essential, it's alien
        if [ "$is_essential" = false ]; then
            found_aliens+=("$basename")
        fi
    done

    # If no alien files found, exit
    if [ ${#found_aliens[@]} -eq 0 ]; then
        return 0
    fi

    # Display found alien files
    echo -e "${YELLOW}⚠ Found unnecessary files in your PromptStash installation:${NC}"
    echo ""
    for alien in "${found_aliens[@]}"; do
        echo -e "  ${YELLOW}•${NC} $alien"
    done
    echo ""
    echo "These files are not needed for using PromptStash and can be safely removed."
    echo ""

    # Ask user what to do
    while true; do
        echo -e "${BLUE}Delete these files?${NC}"
        echo "  1) Yes - Delete now"
        echo "  2) No - Keep them for now"
        echo "  3) Never ask again"
        echo ""
        read -p "Your choice (1/2/3): " choice

        case "$choice" in
            1|yes|y|Y)
                echo ""
                echo -e "${BLUE}Removing unnecessary files...${NC}"
                for alien in "${found_aliens[@]}"; do
                    local full_path="$INSTALL_DIR/$alien"
                    if rm -rf "$full_path" 2>/dev/null; then
                        echo -e "  ${GREEN}✓${NC} Removed $alien"
                    else
                        echo -e "  ${RED}✗${NC} Failed to remove $alien"
                    fi
                done
                echo ""
                echo -e "${GREEN}✓ Cleanup complete!${NC}"
                break
                ;;
            2|no|n|N)
                echo ""
                echo -e "${YELLOW}Keeping files. Run 'promptstash cleanup' to check again later.${NC}"
                break
                ;;
            3|never)
                echo "never" > "$config_file"
                echo ""
                echo -e "${GREEN}✓ Won't ask again. To re-enable, delete: $config_file${NC}"
                break
                ;;
            *)
                echo -e "${RED}Invalid choice. Please enter 1, 2, or 3.${NC}"
                echo ""
                ;;
        esac
    done
}

# Show help
show_help() {
    cat << EOF
PromptStash CLI - A collection of generic, reusable developer prompts

Usage: promptstash [command]

Commands:
  self-update    Update PromptStash to the latest version
  cleanup        Check for and remove unnecessary files
  version        Show the current version
  help           Show this help message

Environment Variables:
  PROMPTSTASH_DIR              Path to the prompts directory
  PROMPTSTASH_NO_UPDATE_CHECK  Set to '1' to disable update checks

Examples:
  promptstash self-update      # Update to the latest version
  promptstash cleanup          # Check for unnecessary files
  promptstash version          # Show current version

Prompts are located in: \$PROMPTSTASH_DIR
Learn more: https://github.com/korotkevics/promptstash
EOF
}

# Main command handler
main() {
    case "$1" in
        self-update)
            self_update
            ;;
        cleanup)
            check_alien_files
            ;;
        version)
            show_version
            ;;
        help|--help|-h|"")
            show_help
            ;;
        *)
            # Unknown command - show error without update check
            echo -e "${RED}Unknown command: $1${NC}"
            echo ""
            show_help
            exit 1
            ;;
    esac

    # Check for updates after successful command (helps keep terminal clean)
    check_for_updates
}

main "$@"
