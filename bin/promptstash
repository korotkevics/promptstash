#!/bin/bash
set -e

# Verify bash is being used (required for array syntax)
if [ -z "$BASH_VERSION" ]; then
    echo "Error: This script requires bash to run."
    echo "Please run with: bash $0 $*"
    exit 1
fi

# PromptStash CLI
# A simple CLI for managing your PromptStash installation

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Determine the installation directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INSTALL_DIR="$(dirname "$SCRIPT_DIR")"
VERSION_FILE="$INSTALL_DIR/.version"
REPO_URL="https://github.com/korotkevics/promptstash.git"
GITHUB_API_URL="https://api.github.com/repos/korotkevics/promptstash/releases/latest"

# Check for updates (unless disabled)
check_for_updates() {
    # Skip if update check is disabled
    if [ "${PROMPTSTASH_NO_UPDATE_CHECK}" = "1" ]; then
        return 0
    fi
    
    # Skip if we checked recently (within last 24 hours)
    local cache_file="$HOME/.promptstash_update_check"
    if [ -f "$cache_file" ]; then
        local last_check=$(cat "$cache_file" 2>/dev/null)

        # Validate that last_check is a number
        if [[ "$last_check" =~ ^[0-9]+$ ]]; then
            local current_time=$(date +%s)
            local time_diff=$((current_time - last_check))

            # 86400 seconds = 24 hours
            if [ $time_diff -lt 86400 ]; then
                return 0
            fi
        else
            # Corrupted cache file, remove it
            rm -f "$cache_file"
        fi
    fi
    
    # Get local version
    if [ ! -f "$VERSION_FILE" ]; then
        return 0
    fi
    local local_version=$(cat "$VERSION_FILE")
    
    # Get latest release version from GitHub API
    local latest_version=""
    local api_response=""

    if command -v curl &> /dev/null; then
        api_response=$(curl -sf --max-time 5 "$GITHUB_API_URL" 2>/dev/null)
    elif command -v wget &> /dev/null; then
        api_response=$(wget -qO- --timeout=5 "$GITHUB_API_URL" 2>/dev/null)
    fi

    # Only proceed if we got a valid response
    if [ -n "$api_response" ] && echo "$api_response" | grep -q '"tag_name"'; then
        if command -v jq &> /dev/null; then
            # Use jq for robust JSON parsing
            latest_version=$(echo "$api_response" | jq -r '.tag_name // empty' 2>/dev/null | sed 's/^v//')
        else
            # Fallback to grep/sed if jq is not available
            latest_version=$(echo "$api_response" | grep -o '"tag_name": *"[^"]*"' | sed 's/"tag_name": *"v*\([^"]*\)"/\1/')
        fi
    fi
    
    # Update cache file
    date +%s > "$cache_file"

    # Compare versions using semantic versioning
    if [ -n "$latest_version" ] && [ "$latest_version" != "$local_version" ]; then
        # Use sort -V for proper semantic version comparison (with fallback for older systems)
        local higher_version=""
        if printf "%s\n%s" "1.0.0" "1.0.1" | sort -V &>/dev/null; then
            higher_version=$(printf "%s\n%s" "$local_version" "$latest_version" | sort -V | tail -1)
        else
            # Fallback: simple string comparison (works for most semantic versions)
            if [ "$latest_version" \> "$local_version" ]; then
                higher_version="$latest_version"
            else
                higher_version="$local_version"
            fi
        fi

        if [ "$higher_version" = "$latest_version" ]; then
            echo -e "${YELLOW}⚡ A new version of promptstash is available (v$latest_version). Run 'promptstash self-update' to upgrade.${NC}"
            echo -e "${YELLOW}   Release notes: https://github.com/korotkevics/promptstash/releases/tag/v$latest_version${NC}"
            echo ""
        fi
    fi
}

# Self-update command
self_update() {
    echo -e "${BLUE}Updating PromptStash...${NC}"
    
    if [ ! -d "$INSTALL_DIR/.git" ]; then
        echo -e "${RED}✗ Error: Not a git repository${NC}"
        echo "Please reinstall PromptStash using the install script."
        exit 1
    fi
    
    cd "$INSTALL_DIR"

    # Check for uncommitted changes to essential files only
    # We only care about changes to files users need, not alien files (tests/, .github/, etc.)
    local essential_paths=(
        ".promptstash"
        "bin"
        ".git"
        ".gitignore"
        ".version"
        "LICENSE"
        "install.sh"
        "docs"
        "static"
        ".context"
    )

    # Check each essential path for uncommitted changes
    for path in "${essential_paths[@]}"; do
        if [ -e "$path" ] && ! git diff-index --quiet HEAD -- "$path" 2>/dev/null; then
            echo -e "${RED}✗ Error: You have uncommitted changes to essential files${NC}"
            echo "Please commit or discard your changes before updating."
            echo "Run 'git status' in $INSTALL_DIR to see your changes."
            exit 1
        fi
    done

    # Fetch latest changes (but don't pull yet)
    echo "Fetching latest changes..."
    git fetch --tags origin

    local before_version=$(cat "$VERSION_FILE" 2>/dev/null || echo "unknown")

    # Check current branch and switch to main if needed
    local current_branch=$(git branch --show-current)
    if [ "$current_branch" != "main" ]; then
        echo "Switching from branch '$current_branch' to 'main'..."
        git checkout main
    fi

    # Check Git version for sparse checkout compatibility (requires Git 2.25+)
    local git_version=$(git --version | grep -oE '[0-9]+\.[0-9]+' | head -1)
    local major=$(echo "$git_version" | cut -d. -f1)
    local minor=$(echo "$git_version" | cut -d. -f2)
    local can_use_sparse=true

    if [ "$major" -lt 2 ] || ([ "$major" -eq 2 ] && [ "$minor" -lt 25 ]); then
        can_use_sparse=false
    fi

    # CRITICAL: Configure sparse checkout BEFORE pull to prevent unwanted files from being pulled
    if ! git config --get core.sparsecheckout &>/dev/null; then
        if [ "$can_use_sparse" = true ]; then
            echo "Migrating to sparse checkout (user-facing files only)..."

            if ! git sparse-checkout init --cone 2>/dev/null; then
                echo -e "${YELLOW}⚠ Warning: Failed to initialize sparse checkout. Continuing with full checkout.${NC}"
            elif ! git sparse-checkout set \
                .promptstash \
                bin \
                docs \
                static \
                .context \
                .gitignore \
                .version \
                LICENSE \
                README.md \
                install.sh 2>/dev/null; then
                echo -e "${YELLOW}⚠ Warning: Failed to configure sparse checkout paths. Continuing with full checkout.${NC}"
            else
                # Verify sparse checkout is working by checking multiple essential paths
                local missing_paths=()
                local check_paths=("bin/promptstash" ".promptstash" ".version")

                for check_path in "${check_paths[@]}"; do
                    if [ ! -e "$INSTALL_DIR/$check_path" ]; then
                        missing_paths+=("$check_path")
                    fi
                done

                if git config --get core.sparsecheckout &>/dev/null && [ ${#missing_paths[@]} -eq 0 ]; then
                    echo -e "${GREEN}✓ Successfully migrated to sparse checkout${NC}"
                else
                    echo -e "${YELLOW}⚠ Warning: Sparse checkout may not be working correctly.${NC}"
                    if [ ${#missing_paths[@]} -gt 0 ]; then
                        echo -e "${YELLOW}  Missing essential files: ${missing_paths[*]}${NC}"
                    fi
                fi
            fi
        else
            echo -e "${YELLOW}⚠ Git version $git_version detected. Sparse checkout requires Git 2.25+. Skipping migration.${NC}"
        fi
    fi

    # Now pull with sparse checkout configured
    echo "Pulling latest changes..."
    git pull origin main

    local after_version=$(cat "$VERSION_FILE" 2>/dev/null || echo "unknown")
    
    # Make sure the CLI is executable
    if [ -f "$INSTALL_DIR/bin/promptstash" ]; then
        chmod +x "$INSTALL_DIR/bin/promptstash"
    fi
    
    # Clear update check cache
    rm -f "$HOME/.promptstash_update_check"

    echo ""
    if [ "$before_version" = "$after_version" ]; then
        echo -e "${GREEN}✓ You are already on the latest version ($after_version)${NC}"
    else
        echo -e "${GREEN}✓ Successfully updated from v$before_version to v$after_version${NC}"
    fi

    # Run cleanup to remove unnecessary files
    echo ""
    check_alien_files
}

# Show version
show_version() {
    if [ -f "$VERSION_FILE" ]; then
        local version=$(cat "$VERSION_FILE")
        echo "PromptStash v$version"
    else
        echo "PromptStash (version unknown)"
    fi
}

# Check for alien files (files not needed in user installations)
check_alien_files() {
    local config_file="$HOME/.promptstash_cleanup_pref"
    local deleted_file="$HOME/.promptstash_deleted_aliens"

    # Check if user said "never ask again"
    if [ -f "$config_file" ]; then
        local pref=$(cat "$config_file" 2>/dev/null)
        if [ "$pref" = "never" ]; then
            return 0
        fi
    fi

    # Load previously deleted aliens
    local deleted_aliens=()
    if [ -f "$deleted_file" ]; then
        while IFS= read -r line; do
            [ -n "$line" ] && deleted_aliens+=("$line")
        done < "$deleted_file"
    fi

    # Define essential files/directories that users need
    # Everything else is considered "alien" and can be removed
    local essential_patterns=(
        ".promptstash"     # The actual prompts
        "bin"              # CLI executable
        ".git"             # Git repository (for updates)
        ".gitignore"       # Git ignore patterns
        ".version"         # Version file
        "LICENSE"          # Legal requirement
        "README.md"        # Documentation
        "install.sh"       # Installation script
        "docs"             # Documentation directory
        "static"           # Static assets (logo, etc.)
        ".context"         # User context files
    )

    local found_aliens=()

    # Check all top-level files/directories
    for item in "$INSTALL_DIR"/{*,.[!.]*}; do
        # Skip if doesn't exist (glob didn't match)
        [ -e "$item" ] || continue

        local basename=$(basename "$item")
        local is_essential=false

        # Check if this item is essential
        for essential in "${essential_patterns[@]}"; do
            if [ "$basename" = "$essential" ]; then
                is_essential=true
                break
            fi
        done

        # CRITICAL SAFETY CHECK: Never allow these paths to be considered alien
        # This is a redundant safety net in case of logic errors above
        case "$basename" in
            .promptstash|bin|.git|.version)
                is_essential=true
                ;;
        esac

        # Check if this item was previously deleted
        local was_deleted=false
        for deleted in "${deleted_aliens[@]}"; do
            if [ "$basename" = "$deleted" ]; then
                was_deleted=true
                break
            fi
        done

        # If not essential and not previously deleted, it's a new alien
        if [ "$is_essential" = false ] && [ "$was_deleted" = false ]; then
            found_aliens+=("$basename")
        fi
    done

    # If no alien files found, exit
    if [ ${#found_aliens[@]} -eq 0 ]; then
        return 0
    fi

    # Display found alien files
    echo -e "${YELLOW}⚠ Found unrelated files in your PromptStash installation:${NC}"
    echo ""
    for alien in "${found_aliens[@]}"; do
        echo -e "  ${YELLOW}•${NC} $alien"
    done
    echo ""
    echo "These files are not part of a standard PromptStash installation."
    echo "They may have been added manually or left over from a development setup."
    echo ""

    # Ask user what to do
    while true; do
        echo -e "${BLUE}Delete these files?${NC}"
        echo "  1) Yes - Delete now"
        echo "  2) No - Keep them for now"
        echo "  3) Never ask again"
        echo ""
        read -p "Your choice (1/2/3): " choice

        case "$choice" in
            1|yes|y|Y)
                echo ""
                echo -e "${BLUE}Removing unnecessary files...${NC}"
                for alien in "${found_aliens[@]}"; do
                    local full_path="$INSTALL_DIR/$alien"
                    if rm -rf "$full_path" 2>/dev/null; then
                        echo -e "  ${GREEN}✓${NC} Removed $alien"
                        # Remember this deletion (with lock to prevent race conditions)
                        local lock_file="$deleted_file.lock"
                        local timeout=100  # 100 iterations * 0.1s = 10 seconds
                        local waited=0

                        # Setup trap to cleanup lock file on exit
                        trap 'rm -f "$lock_file"' EXIT INT TERM

                        # Wait for lock (with timeout)
                        while [ -f "$lock_file" ] && [ $waited -lt $timeout ]; do
                            sleep 0.1
                            waited=$((waited + 1))
                        done

                        # Acquire lock
                        touch "$lock_file"
                        # Append deletion only if not already recorded (prevent duplicates)
                        if ! grep -Fxq "$alien" "$deleted_file" 2>/dev/null; then
                            echo "$alien" >> "$deleted_file"
                        fi
                        # Release lock
                        rm -f "$lock_file"
                        trap - EXIT INT TERM
                    else
                        echo -e "  ${RED}✗${NC} Failed to remove $alien"
                    fi
                done
                echo ""
                echo -e "${GREEN}✓ Cleanup complete!${NC}"
                break
                ;;
            2|no|n|N)
                echo ""
                echo -e "${YELLOW}Keeping files. Run 'promptstash cleanup' to check again later.${NC}"
                break
                ;;
            3|never)
                echo "never" > "$config_file"
                echo ""
                echo -e "${GREEN}✓ Won't ask again. To re-enable, delete: $config_file${NC}"
                break
                ;;
            *)
                echo -e "${RED}Invalid choice. Please enter 1, 2, or 3.${NC}"
                echo ""
                ;;
        esac
    done
}

# List all prompts (non-interactive)
list_prompts() {
    local prompts_dir="${PROMPTSTASH_DIR:-$INSTALL_DIR}/.promptstash"

    if [ ! -d "$prompts_dir" ]; then
        echo -e "${RED}✗ Error: Prompts directory not found: $prompts_dir${NC}"
        exit 1
    fi

    # Get all .md files and sort them alphabetically
    local prompts=()
    while IFS= read -r prompt; do
        prompts+=("$prompt")
    done < <(find "$prompts_dir" -maxdepth 1 -name "*.md" -type f -exec basename {} \; | sort)

    if [ ${#prompts[@]} -eq 0 ]; then
        echo -e "${YELLOW}No prompts found in $prompts_dir${NC}"
        return 0
    fi

    # Display prompts in alphanumeric order
    for prompt in "${prompts[@]}"; do
        echo "$prompt"
    done
}

# Pick a prompt interactively
pick_prompts() {
    local mode="$1"
    local prompts_dir="${PROMPTSTASH_DIR:-$INSTALL_DIR}/.promptstash"

    if [ ! -d "$prompts_dir" ]; then
        echo -e "${RED}✗ Error: Prompts directory not found: $prompts_dir${NC}"
        exit 1
    fi

    # Get all .md files and sort them alphabetically
    local prompts=()
    while IFS= read -r prompt; do
        prompts+=("$prompt")
    done < <(find "$prompts_dir" -maxdepth 1 -name "*.md" -type f -exec basename {} \; | sort)

    if [ ${#prompts[@]} -eq 0 ]; then
        echo -e "${YELLOW}No prompts found in $prompts_dir${NC}"
        exit 1
    fi

    # Detect clipboard command (use array for proper handling of multi-word commands)
    local -a clipboard_cmd=()
    if command -v pbcopy &> /dev/null; then
        clipboard_cmd=("pbcopy")
    elif command -v xclip &> /dev/null; then
        clipboard_cmd=("xclip" "-selection" "clipboard")
    elif command -v wl-copy &> /dev/null; then
        clipboard_cmd=("wl-copy")
    else
        echo -e "${RED}✗ Error: No clipboard command found${NC}"
        echo ""
        echo "The pick command requires a clipboard utility. Please install one:"
        echo ""
        echo "  macOS:        pbcopy (pre-installed)"
        echo "  Linux (X11):  sudo apt install xclip"
        echo "  Linux (Wayland): sudo apt install wl-clipboard"
        echo ""
        exit 1
    fi

    # Display numbered list
    echo -e "${BLUE}Available prompts:${NC}"
    echo ""
    local index=1
    for prompt in "${prompts[@]}"; do
        printf "%d - %s\n" "$index" "$prompt"
        index=$((index + 1))
    done
    echo ""

    # Interactive loop for user input
    while true; do
        read -p "Select a prompt number (or 'q' to quit): " choice

        # Check if user wants to quit
        if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
            echo "Cancelled."
            exit 0
        fi

        # Validate input is a number
        if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}✗ Error: Invalid input. Please enter a number.${NC}"
            continue
        fi

        # Validate number is in range
        if [ "$choice" -lt 1 ] || [ "$choice" -gt ${#prompts[@]} ]; then
            echo -e "${RED}✗ Error: Invalid selection. Please choose a number between 1 and ${#prompts[@]}.${NC}"
            continue
        fi

        # Get selected prompt (arrays are 0-indexed)
        local selected_prompt="${prompts[$((choice - 1))]}"
        local prompt_path="$prompts_dir/$selected_prompt"

        # Copy to clipboard using helper function
        copy_to_clipboard "$mode" "$selected_prompt" "$prompt_path" "${clipboard_cmd[@]}"

        # Successfully copied, exit the loop
        break
    done
}

# Copy to clipboard based on mode
# Args: mode, selected_prompt_name, prompt_path, clipboard_cmd_array
copy_to_clipboard() {
    local mode="$1"
    local selected_prompt="$2"
    local prompt_path="$3"
    shift 3
    local -a clipboard_cmd=("$@")

    case "$mode" in
        name)
            if echo -n "$selected_prompt" | "${clipboard_cmd[@]}" 2>/dev/null; then
                echo -e "${GREEN}✓ Saved to clipboard: $selected_prompt${NC}"
            else
                echo -e "${RED}✗ Error: Failed to copy to clipboard: $selected_prompt${NC}"
                echo "The clipboard command (${clipboard_cmd[*]}) failed. Please ensure it's properly configured."
                exit 1
            fi
            ;;
        content)
            if cat "$prompt_path" | "${clipboard_cmd[@]}" 2>/dev/null; then
                echo -e "${GREEN}✓ Saved to clipboard: contents of $selected_prompt${NC}"
            else
                echo -e "${RED}✗ Error: Failed to copy to clipboard: contents of $selected_prompt${NC}"
                echo "The clipboard command (${clipboard_cmd[*]}) failed. Please ensure it's properly configured."
                exit 1
            fi
            ;;
        path)
            if echo -n "$prompt_path" | "${clipboard_cmd[@]}" 2>/dev/null; then
                echo -e "${GREEN}✓ Saved to clipboard: $prompt_path${NC}"
            else
                echo -e "${RED}✗ Error: Failed to copy to clipboard: $prompt_path${NC}"
                echo "The clipboard command (${clipboard_cmd[*]}) failed. Please ensure it's properly configured."
                exit 1
            fi
            ;;
        *)
            echo -e "${RED}✗ Error: Unknown mode: $mode${NC}"
            exit 1
            ;;
    esac
}

# Show search usage helper
show_search_usage() {
    {
        echo -e "${RED}✗ Error: search command requires a query${NC}"
        echo ""
        cat <<'EOF'
Usage: promptstash search [name|content|path] <query>

  search <query>          - List matching prompts (non-interactive)
  search name <query>     - Pick from matches and copy filename
  search content <query>  - Pick from matches and copy file contents
  search path <query>     - Pick from matches and copy file path
EOF
    } >&2
    exit 1
}

# Show match usage helper
show_match_usage() {
    {
        echo -e "${RED}✗ Error: match command requires a mode and pattern${NC}"
        echo ""
        cat <<'EOF'
Usage: promptstash match [name|content|path] <pattern>

  match content <pattern>  - Return file contents of best match
  match path <pattern>     - Return file path of best match
  match name <pattern>     - Return filename of best match

Fuzzy matching uses greedy left-to-right character matching. All pattern
characters must appear in the filename in order.

Examples:
  'commt' matches 'commit.md' (typo - missing 'i')
  'cmt' matches 'commit.md' (abbreviation)

Limitations:
  - Pattern characters must all be present (e.g., 'cmit' missing 'm' fails)
  - Uses greedy matching (first occurrence taken, not optimal arrangement)
  - Pattern 'abc' vs 'bca' may score poorly due to character order mismatch

Unlike 'search' which finds all matches interactively, 'match' returns
the single best fuzzy match directly.
EOF
    } >&2
    exit 1
}

# Calculate fuzzy match score using character-order-preserving distance
# Lower score = better match
#
# Algorithm: Character-by-character matching that preserves order, with penalties
# for distance between matches and missing characters. Not true Levenshtein distance.
#
# Performance: O(n*m) per candidate, where n=pattern length, m=candidate length.
# For the entire match operation: O(p*n*m) where p=number of prompts.
# Typical case: 100 prompts, 10-char pattern, 20-char avg filename = ~20,000 comparisons.
# The algorithm is optimized for typical prompt collections (<200 files).
# Performance may degrade with very large collections (>500 prompts) or very long
# filenames (>100 chars), but such cases are rare in practice.
#
# UTF-8 Note: This function uses bash string slicing (${string:pos:len}) which
# handles multi-byte UTF-8 characters correctly in bash 4.3+ with proper locale
# settings (e.g., LC_CTYPE=en_US.UTF-8). For older bash or non-UTF-8 locales,
# matching may be incorrect for non-ASCII characters (emojis, accented chars).
# This is acceptable for typical prompt filenames which use ASCII characters.
fuzzy_match_score() {
    local pattern="$1"
    local candidate="$2"
    local penalty="${3:-100}"  # Default 100, but can be overridden

    # Convert to lowercase for case-insensitive matching
    # Using bash 4.0+ parameter expansion for better UTF-8 handling and performance.
    # This script requires bash 4.x (uses read -d ''), so we use the built-in
    # lowercase expansion which handles multi-byte UTF-8 characters correctly
    # when LC_CTYPE is set to a UTF-8 locale (e.g., en_US.UTF-8).
    pattern=${pattern,,}
    candidate=${candidate,,}

    # Exact match gets score 0
    if [ "$pattern" = "$candidate" ]; then
        echo "0"
        return
    fi

    # Check if pattern is substring of candidate (low score = good)
    if echo "$candidate" | grep -Fq "$pattern"; then
        # Score based on length difference
        local len_diff=$((${#candidate} - ${#pattern}))
        echo "$len_diff"
        return
    fi

    # Simple character-by-character scoring
    # Count matching characters in order
    local score=0
    local pattern_idx=0
    local pattern_len=${#pattern}
    local candidate_len=${#candidate}

    # For each character in pattern, find it in candidate
    for ((i=0; i<pattern_len; i++)); do
        local char="${pattern:$i:1}"
        local found=false

        # Search for character in remaining part of candidate
        for ((j=pattern_idx; j<candidate_len; j++)); do
            if [ "${candidate:$j:1}" = "$char" ]; then
                # Found match, add distance to score
                score=$((score + j - pattern_idx))
                pattern_idx=$((j + 1))
                found=true
                break
            fi
        done

        # Character not found, add penalty
        # The penalty (default 100) ensures missing characters heavily penalize the score,
        # making matches with all characters present rank much higher.
        # Note: This penalty value is proportional to MATCH_THRESHOLD (default 50).
        # The penalty is passed as a parameter, defaulting to 2x the threshold.
        # Since penalty=100 and threshold=50, patterns missing even 1 character will
        # score >100, which exceeds the threshold and fails to match. This is intentional:
        # we want exact or near-exact character matches, not partial matches.
        #
        # Greedy left-to-right matching without backtracking: When a character is
        # not found in the remaining candidate string, we add a penalty but don't
        # advance pattern_idx. This means the next pattern character will search
        # from the same position. Once a match succeeds, pattern_idx advances past
        # that position, so earlier candidate positions cannot be revisited even if
        # later pattern chars fail.
        #
        # Example: pattern="abc", candidate="bca"
        #   - i=0: pattern[0]='a' searches from pattern_idx=0
        #     Checks candidate[0]='b' (no match), candidate[1]='c' (no match), candidate[2]='a' (MATCH!)
        #     Score +2 (distance from position 0 to position 2), pattern_idx→3, found=true
        #   - i=1: pattern[1]='b' searches from pattern_idx=3 (past end of candidate)
        #     No characters remaining to search, found=false, penalty +100
        #   - i=2: pattern[2]='c' searches from pattern_idx=3 (past end of candidate)
        #     No characters remaining to search, found=false, penalty +100
        #   Final score: 2 + 100 + 100 + 0 (length diff) = 202
        #   Note: Once pattern_idx advances past a position, earlier positions cannot be revisited.
        #   This greedy approach means the first match is always taken, even if a later arrangement
        #   would produce a better overall score.
        #
        # Limitation: This greedy first-match approach doesn't always find the optimal
        # character arrangement. For example, pattern="abc" vs candidate="bca" scores 202
        # (matches 'a' at pos 2, then can't find 'b' or 'c'), while pattern="abc" vs
        # candidate="cab" scores 101 (matches 'a' at pos 1, 'b' at pos 2, can't find 'c').
        # Despite "bca" having all characters as a proper subsequence [b,c,a], it scores
        # worse than "cab" which only has [a,b] in order. This is acceptable for fuzzy
        # filename matching where we prioritize simplicity and performance over optimal
        # subsequence detection.
        #
        # Real-world example: pattern="deb" scores differently for:
        #   - "debug" (score 2) - matches 'd' at pos 0, 'e' at pos 1, 'b' at pos 2
        #   - "embed" (score 206) - matches 'd' at pos 4, can't find 'e' or 'b' after that
        # The "embed" case demonstrates the greedy limitation: matching 'd' first prevents
        # finding the earlier 'e' and 'b'. However, "embed" scoring >200 correctly fails
        # the threshold anyway, so this limitation rarely affects practical usage.
        if [ "$found" = false ]; then
            score=$((score + penalty))
        fi
    done

    # Add penalty for length difference (using absolute value to avoid overflow)
    local len_diff=$((candidate_len - pattern_len))
    if [ "$len_diff" -lt 0 ]; then
        len_diff=$((-len_diff))
    fi
    score=$((score + len_diff))

    echo "$score"
}

# Match a prompt by filename using fuzzy matching
match_prompt() {
    local mode="$1"
    local pattern="$2"
    local prompts_dir="${PROMPTSTASH_DIR:-$INSTALL_DIR}/.promptstash"

    if [ ! -d "$prompts_dir" ]; then
        echo -e "${RED}✗ Error: Prompts directory not found: $prompts_dir${NC}" >&2
        exit 1
    fi

    if [ -z "$pattern" ]; then
        show_match_usage
    fi

    # Get all .md files (using -print0 for safe handling of special characters)
    # Note: -maxdepth 1 restricts search to top-level directory only, preventing
    # nested subdirectory organization. This is intentional to keep prompts in a
    # flat structure for simplicity and performance.
    local -a all_prompts=()

    # Process find output directly (can't use command substitution with -print0)
    # because bash strips null bytes from $(...) output
    while IFS= read -r -d '' filepath; do
        all_prompts+=("$(basename "$filepath")")
    done < <(find "$prompts_dir" -maxdepth 1 -name "*.md" -type f -print0 2>/dev/null | sort -z)

    if [ ${#all_prompts[@]} -eq 0 ]; then
        echo -e "${RED}✗ Error: No prompts found in $prompts_dir${NC}" >&2
        exit 1
    fi

    # Set threshold and penalty (penalty is always 2x threshold for consistency)
    # Can be overridden via PROMPTSTASH_MATCH_THRESHOLD environment variable
    local MATCH_THRESHOLD="${PROMPTSTASH_MATCH_THRESHOLD:-50}"
    local PENALTY=$((MATCH_THRESHOLD * 2))

    # Calculate fuzzy match scores for each prompt
    local -a scored_prompts=()
    for prompt in "${all_prompts[@]}"; do
        # Remove .md extension for matching
        local prompt_base="${prompt%.md}"
        local score=$(fuzzy_match_score "$pattern" "$prompt_base" "$PENALTY")
        scored_prompts+=("$score:$prompt")
    done

    # Sort by score (numerically) to find best match
    # Use alphanumeric sorting as tiebreaker for deterministic results
    # (e.g., if 'pr.md' and 'pre.md' both score 0, 'pr.md' wins)
    # Using sort is O(n log n) vs O(n²) for manual iteration
    local best_entry=$(printf '%s\n' "${scored_prompts[@]}" | sort -t: -k1,1n -k2 | head -1)
    local best_score="${best_entry%%:*}"
    local best_match="${best_entry#*:}"

    # Check if we have a reasonable match
    # With the scoring algorithm:
    # - Missing character penalty = 2x threshold (default: penalty=100, threshold=50)
    # - This ensures any pattern missing even 1 character will score >threshold
    # - Distance penalties accumulate based on character positions
    # - Example: "commt" → "commit" scores ~1 (substring match with length diff)
    # - Example: "cmmt" → "commit" scores penalty+ (missing 'o' character, fails threshold)
    # - Rationale: Penalty at 2x threshold accepts minor typos/abbreviations while
    #   rejecting patterns missing characters or too dissimilar
    if [ "$best_score" -gt "$MATCH_THRESHOLD" ]; then
        echo -e "${RED}✗ Error: No matching prompt found for pattern '$pattern'${NC}" >&2
        echo "" >&2
        echo "Top 3 closest matches (threshold: $MATCH_THRESHOLD):" >&2
        printf '%s\n' "${scored_prompts[@]}" | sort -t: -k1,1n -k2 | head -3 | while IFS=: read -r score prompt; do
            echo "  - ${prompt%.md} (score: $score)" >&2
        done
        echo "" >&2
        echo "Try using 'promptstash search $pattern' to see all available prompts." >&2
        exit 1
    fi

    # Return based on mode
    local prompt_path="$prompts_dir/$best_match"

    # Note: TOCTOU race condition - file could be deleted between matching and reading.
    # We handle this by catching failures and providing clear error messages.

    case "$mode" in
        name)
            echo "$best_match"
            ;;
        content)
            if ! cat "$prompt_path" 2>/dev/null; then
                echo -e "${RED}✗ Error: Matched prompt file may have been deleted during operation or is unreadable${NC}" >&2
                exit 1
            fi
            ;;
        path)
            echo "$prompt_path"
            ;;
        *)
            echo -e "${RED}✗ Error: Unknown mode: $mode${NC}" >&2
            exit 1
            ;;
    esac
}

# Search prompts by filename and/or content
search_prompts() {
    local mode="$1"
    local query="$2"
    local prompts_dir="${PROMPTSTASH_DIR:-$INSTALL_DIR}/.promptstash"

    if [ ! -d "$prompts_dir" ]; then
        echo -e "${RED}✗ Error: Prompts directory not found: $prompts_dir${NC}"
        exit 1
    fi

    if [ -z "$query" ]; then
        show_search_usage
    fi

    # Detect color support (check if terminal supports colors)
    local color_flag="never"
    if [ -t 1 ] && command -v tput &>/dev/null && [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ]; then
        color_flag="always"
    fi

    # Store matches: filename, matching line (for display)
    local -a match_files=()
    local -a match_contexts=()

    # Search through all .md files
    while IFS= read -r filepath; do
        local filename="${filepath##*/}"
        local found_match=false
        local match_context=""

        # Check if filename matches (case-insensitive, literal string)
        if echo "$filename" | grep -Fiq "$query"; then
            found_match=true
            # Highlight match in filename using grep color (portable approach)
            # Use GREP_COLORS to set bold red for matches
            match_context=$(echo "$filename" | GREP_COLORS='ms=01;31' grep -Fi --color="$color_flag" "$query" || echo "$filename")
        fi

        # Search file contents (case-insensitive, literal string)
        if grep -Fiq "$query" "$filepath"; then
            found_match=true
            # Get first matching line with context and highlight using grep color
            local matching_line=$(GREP_COLORS='ms=01;31' grep -Fi -m 1 --color="$color_flag" "$query" "$filepath" | sed 's/^[[:space:]]*//' | cut -c1-100)
            if [ -n "$matching_line" ]; then
                if [ -z "$match_context" ]; then
                    match_context="$matching_line"
                else
                    match_context="$match_context"$'\n'"  $matching_line"
                fi
            fi
        fi

        if [ "$found_match" = true ]; then
            match_files+=("$filename")
            match_contexts+=("$match_context")
        fi
    done < <(find "$prompts_dir" -maxdepth 1 -name "*.md" -type f | sort)

    # Check if prompts directory has any .md files
    if [ ${#match_files[@]} -eq 0 ]; then
        # Check if directory is empty
        local file_count=$(find "$prompts_dir" -maxdepth 1 -name "*.md" -type f | wc -l)
        if [ "$file_count" -eq 0 ]; then
            echo -e "${RED}✗ Error: No .md files found in prompts directory: $prompts_dir${NC}"
            exit 1
        fi
    fi

    # Check if any matches found
    if [ ${#match_files[@]} -eq 0 ]; then
        echo "No matches found in file names or file contents for \`$query\`."
        exit 0
    fi

    # Non-interactive mode: just list matches
    if [ "$mode" = "list" ]; then
        for i in "${!match_files[@]}"; do
            echo "- \`${match_files[$i]}\`"
            if [ -n "${match_contexts[$i]}" ]; then
                echo "  ${match_contexts[$i]}"
            fi
        done
        return 0
    fi

    # Interactive mode: numbered list
    # Detect clipboard command (use array for proper handling of multi-word commands)
    local -a clipboard_cmd=()
    if command -v pbcopy &> /dev/null; then
        clipboard_cmd=("pbcopy")
    elif command -v xclip &> /dev/null; then
        clipboard_cmd=("xclip" "-selection" "clipboard")
    elif command -v wl-copy &> /dev/null; then
        clipboard_cmd=("wl-copy")
    else
        echo -e "${RED}✗ Error: No clipboard command found${NC}"
        echo ""
        echo "The search command with name/content/path requires a clipboard utility. Please install one:"
        echo ""
        echo "  macOS:        pbcopy (pre-installed)"
        echo "  Linux (X11):  sudo apt install xclip"
        echo "  Linux (Wayland): sudo apt install wl-clipboard"
        echo ""
        exit 1
    fi

    # Display numbered matches
    echo ""
    for i in "${!match_files[@]}"; do
        local num=$((i + 1))
        echo "$num - \`${match_files[$i]}\`"
        if [ -n "${match_contexts[$i]}" ]; then
            echo "  ${match_contexts[$i]}"
        fi
    done
    echo ""

    # Prompt for selection
    while true; do
        read -p "Please select a prompt number to copy to clipboard (or 'q' to quit): " choice

        # Check if user wants to quit
        if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
            echo "Cancelled."
            exit 0
        fi

        # Validate input is a number
        if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}✗ Error: Invalid input. Please enter a number.${NC}"
            continue
        fi

        # Validate number is in range
        if [ "$choice" -lt 1 ] || [ "$choice" -gt ${#match_files[@]} ]; then
            echo -e "${RED}✗ Error: Invalid selection. Please choose a number between 1 and ${#match_files[@]}.${NC}"
            continue
        fi

        # Get selected prompt (arrays are 0-indexed)
        local selected_prompt="${match_files[$((choice - 1))]}"
        local prompt_path="$prompts_dir/$selected_prompt"

        # Copy to clipboard using helper function
        copy_to_clipboard "$mode" "$selected_prompt" "$prompt_path" "${clipboard_cmd[@]}"

        # Successfully copied, exit the loop
        break
    done
}

# Show help
show_help() {
    cat << EOF
PromptStash CLI - A collection of generic, reusable developer prompts

Usage: promptstash [command]

Commands:
  list             List all available prompts (non-interactive)
  pick name        Interactive prompt picker - copies filename to clipboard
  pick content     Interactive prompt picker - copies file contents to clipboard
  pick path        Interactive prompt picker - copies absolute path to clipboard
  search <query>           Search prompts and list matches (non-interactive)
  search name <query>      Search prompts and pick - copies filename to clipboard
  search content <query>   Search prompts and pick - copies file contents to clipboard
  search path <query>      Search prompts and pick - copies absolute path to clipboard
  match name <pattern>     Fuzzy match prompt and output filename (e.g., commit.md)
  match content <pattern>  Fuzzy match prompt and output file contents
  match path <pattern>     Fuzzy match prompt and output file path
  self-update      Update PromptStash to the latest version
  cleanup          Check for and remove unnecessary files
  version          Show the current version
  help             Show this help message

Environment Variables:
  PROMPTSTASH_DIR              Path to the prompts directory
  PROMPTSTASH_NO_UPDATE_CHECK  Set to '1' to disable update checks

Examples:
  promptstash list                # List all prompts
  promptstash pick content        # Interactive picker
  promptstash search commit       # Search and list matches
  promptstash search name debug   # Search and pick interactively
  promptstash match content commt # Fuzzy match 'commt' to 'commit.md' and show contents
  promptstash self-update         # Update to latest version

Prompts are located in: \$PROMPTSTASH_DIR
Learn more: https://github.com/korotkevics/promptstash
EOF
}

# Main command handler
main() {
    case "$1" in
        list)
            list_prompts
            ;;
        pick)
            # Pick command requires a subcommand
            case "$2" in
                name|content|path)
                    pick_prompts "$2"
                    ;;
                "")
                    echo -e "${RED}✗ Error: pick command requires a subcommand${NC}"
                    echo ""
                    echo "Usage: promptstash pick [name|content|path]"
                    echo ""
                    echo "  name     - Copy filename to clipboard"
                    echo "  content  - Copy file contents to clipboard"
                    echo "  path     - Copy absolute path to clipboard"
                    exit 1
                    ;;
                *)
                    echo -e "${RED}✗ Unknown pick subcommand: $2${NC}"
                    echo ""
                    echo "Usage: promptstash pick [name|content|path]"
                    exit 1
                    ;;
            esac
            ;;
        search)
            # Search command can be used with or without a mode
            case "$2" in
                name|content|path)
                    # Interactive search with mode
                    search_prompts "$2" "$3"
                    ;;
                "")
                    # No query provided
                    show_search_usage
                    ;;
                *)
                    # Non-interactive search (query provided directly)
                    search_prompts "list" "$2"
                    ;;
            esac
            ;;
        match)
            # Match command requires a mode and pattern
            case "$2" in
                name|content|path)
                    match_prompt "$2" "$3"
                    ;;
                "")
                    show_match_usage
                    ;;
                *)
                    echo -e "${RED}✗ Unknown match mode: $2${NC}"
                    echo ""
                    show_match_usage
                    ;;
            esac
            ;;
        self-update)
            self_update
            ;;
        cleanup)
            check_alien_files
            ;;
        version)
            show_version
            ;;
        help|--help|-h|"")
            show_help
            ;;
        *)
            # Unknown command - show error without update check
            echo -e "${RED}Unknown command: $1${NC}"
            echo ""
            show_help
            exit 1
            ;;
    esac

    # Check for updates after successful command (helps keep terminal clean)
    check_for_updates
}

main "$@"
