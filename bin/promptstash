#!/bin/bash
set -e

# Verify bash is being used (required for array syntax)
if [ -z "$BASH_VERSION" ]; then
    echo "Error: This script requires bash to run."
    echo "Please run with: bash $0 $*"
    exit 1
fi

# PromptStash CLI
# A simple CLI for managing your PromptStash installation

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Determine the installation directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
INSTALL_DIR="$(dirname "$SCRIPT_DIR")"
VERSION_FILE="$INSTALL_DIR/.version"
REPO_URL="https://github.com/korotkevics/promptstash.git"
GITHUB_API_URL="https://api.github.com/repos/korotkevics/promptstash/releases/latest"

# Check for updates (unless disabled)
check_for_updates() {
    # Skip if update check is disabled
    if [ "${PROMPTSTASH_NO_UPDATE_CHECK}" = "1" ]; then
        return 0
    fi
    
    # Skip if we checked recently (within last 24 hours)
    local cache_file="$HOME/.promptstash_update_check"
    if [ -f "$cache_file" ]; then
        local last_check=$(cat "$cache_file" 2>/dev/null)

        # Validate that last_check is a number
        if [[ "$last_check" =~ ^[0-9]+$ ]]; then
            local current_time=$(date +%s)
            local time_diff=$((current_time - last_check))

            # 86400 seconds = 24 hours
            if [ $time_diff -lt 86400 ]; then
                return 0
            fi
        else
            # Corrupted cache file, remove it
            rm -f "$cache_file"
        fi
    fi
    
    # Get local version
    if [ ! -f "$VERSION_FILE" ]; then
        return 0
    fi
    local local_version=$(cat "$VERSION_FILE")
    
    # Get latest release version from GitHub API
    local latest_version=""
    local api_response=""

    if command -v curl &> /dev/null; then
        api_response=$(curl -sf --max-time 5 "$GITHUB_API_URL" 2>/dev/null)
    elif command -v wget &> /dev/null; then
        api_response=$(wget -qO- --timeout=5 "$GITHUB_API_URL" 2>/dev/null)
    fi

    # Only proceed if we got a valid response
    if [ -n "$api_response" ] && echo "$api_response" | grep -q '"tag_name"'; then
        if command -v jq &> /dev/null; then
            # Use jq for robust JSON parsing
            latest_version=$(echo "$api_response" | jq -r '.tag_name // empty' 2>/dev/null | sed 's/^v//')
        else
            # Fallback to grep/sed if jq is not available
            latest_version=$(echo "$api_response" | grep -o '"tag_name": *"[^"]*"' | sed 's/"tag_name": *"v*\([^"]*\)"/\1/')
        fi
    fi
    
    # Update cache file
    date +%s > "$cache_file"

    # Compare versions using semantic versioning
    if [ -n "$latest_version" ] && [ "$latest_version" != "$local_version" ]; then
        # Use sort -V for proper semantic version comparison (with fallback for older systems)
        local higher_version=""
        if printf "%s\n%s" "1.0.0" "1.0.1" | sort -V &>/dev/null; then
            higher_version=$(printf "%s\n%s" "$local_version" "$latest_version" | sort -V | tail -1)
        else
            # Fallback: simple string comparison (works for most semantic versions)
            if [ "$latest_version" \> "$local_version" ]; then
                higher_version="$latest_version"
            else
                higher_version="$local_version"
            fi
        fi

        if [ "$higher_version" = "$latest_version" ]; then
            echo -e "${YELLOW}⚡ A new version of promptstash is available (v$latest_version). Run 'promptstash self-update' to upgrade.${NC}"
            echo -e "${YELLOW}   Release notes: https://github.com/korotkevics/promptstash/releases/tag/v$latest_version${NC}"
            echo ""
        fi
    fi
}

# Self-update command
self_update() {
    echo -e "${BLUE}Updating PromptStash...${NC}"
    
    if [ ! -d "$INSTALL_DIR/.git" ]; then
        echo -e "${RED}✗ Error: Not a git repository${NC}"
        echo "Please reinstall PromptStash using the install script."
        exit 1
    fi
    
    cd "$INSTALL_DIR"

    # Check for uncommitted changes to essential files only
    # We only care about changes to files users need, not alien files (tests/, .github/, etc.)
    local essential_paths=(
        ".promptstash"
        "bin"
        ".git"
        ".gitignore"
        ".version"
        "LICENSE"
        "install.sh"
        "docs"
        "static"
        ".context"
    )

    # Check each essential path for uncommitted changes
    for path in "${essential_paths[@]}"; do
        if [ -e "$path" ] && ! git diff-index --quiet HEAD -- "$path" 2>/dev/null; then
            echo -e "${RED}✗ Error: You have uncommitted changes to essential files${NC}"
            echo "Please commit or discard your changes before updating."
            echo "Run 'git status' in $INSTALL_DIR to see your changes."
            exit 1
        fi
    done

    # Fetch and pull latest changes
    echo "Fetching latest changes..."
    git fetch --tags origin

    local before_version=$(cat "$VERSION_FILE" 2>/dev/null || echo "unknown")

    # Check current branch and switch to main if needed
    local current_branch=$(git branch --show-current)
    if [ "$current_branch" != "main" ]; then
        echo "Switching from branch '$current_branch' to 'main'..."
        git checkout main
    fi

    git pull origin main

    # Check Git version for sparse checkout compatibility (requires Git 2.25+)
    local git_version=$(git --version | grep -oE '[0-9]+\.[0-9]+' | head -1)
    local major=$(echo "$git_version" | cut -d. -f1)
    local minor=$(echo "$git_version" | cut -d. -f2)
    local can_use_sparse=true

    if [ "$major" -lt 2 ] || ([ "$major" -eq 2 ] && [ "$minor" -lt 25 ]); then
        can_use_sparse=false
    fi

    # Ensure sparse checkout is configured (for installations made before sparse checkout feature)
    # CRITICAL: Migration happens AFTER pull to avoid deleting files before they're updated
    if ! git config --get core.sparsecheckout &>/dev/null; then
        if [ "$can_use_sparse" = true ]; then
            echo "Migrating to sparse checkout (user-facing files only)..."

            if ! git sparse-checkout init --cone 2>/dev/null; then
                echo -e "${YELLOW}⚠ Warning: Failed to initialize sparse checkout. Continuing with full checkout.${NC}"
            elif ! git sparse-checkout set \
                .promptstash \
                bin \
                docs \
                static \
                .context \
                .gitignore \
                .version \
                LICENSE \
                README.md \
                install.sh 2>/dev/null; then
                echo -e "${YELLOW}⚠ Warning: Failed to configure sparse checkout paths. Continuing with full checkout.${NC}"
            else
                # Verify sparse checkout is working by checking multiple essential paths
                local missing_paths=()
                local check_paths=("bin/promptstash" ".promptstash" ".version")

                for check_path in "${check_paths[@]}"; do
                    if [ ! -e "$INSTALL_DIR/$check_path" ]; then
                        missing_paths+=("$check_path")
                    fi
                done

                if git config --get core.sparsecheckout &>/dev/null && [ ${#missing_paths[@]} -eq 0 ]; then
                    echo -e "${GREEN}✓ Successfully migrated to sparse checkout${NC}"
                else
                    echo -e "${YELLOW}⚠ Warning: Sparse checkout may not be working correctly.${NC}"
                    if [ ${#missing_paths[@]} -gt 0 ]; then
                        echo -e "${YELLOW}  Missing essential files: ${missing_paths[*]}${NC}"
                    fi
                fi
            fi
        else
            echo -e "${YELLOW}⚠ Git version $git_version detected. Sparse checkout requires Git 2.25+. Skipping migration.${NC}"
        fi
    fi
    
    local after_version=$(cat "$VERSION_FILE" 2>/dev/null || echo "unknown")
    
    # Make sure the CLI is executable
    if [ -f "$INSTALL_DIR/bin/promptstash" ]; then
        chmod +x "$INSTALL_DIR/bin/promptstash"
    fi
    
    # Clear update check cache
    rm -f "$HOME/.promptstash_update_check"

    echo ""
    if [ "$before_version" = "$after_version" ]; then
        echo -e "${GREEN}✓ You are already on the latest version ($after_version)${NC}"
    else
        echo -e "${GREEN}✓ Successfully updated from v$before_version to v$after_version${NC}"
    fi

    # Run cleanup to remove unnecessary files
    echo ""
    check_alien_files
}

# Show version
show_version() {
    if [ -f "$VERSION_FILE" ]; then
        local version=$(cat "$VERSION_FILE")
        echo "PromptStash v$version"
    else
        echo "PromptStash (version unknown)"
    fi
}

# Check for alien files (files not needed in user installations)
check_alien_files() {
    local config_file="$HOME/.promptstash_cleanup_pref"
    local deleted_file="$HOME/.promptstash_deleted_aliens"

    # Check if user said "never ask again"
    if [ -f "$config_file" ]; then
        local pref=$(cat "$config_file" 2>/dev/null)
        if [ "$pref" = "never" ]; then
            return 0
        fi
    fi

    # Load previously deleted aliens
    local deleted_aliens=()
    if [ -f "$deleted_file" ]; then
        while IFS= read -r line; do
            [ -n "$line" ] && deleted_aliens+=("$line")
        done < "$deleted_file"
    fi

    # Define essential files/directories that users need
    # Everything else is considered "alien" and can be removed
    local essential_patterns=(
        ".promptstash"     # The actual prompts
        "bin"              # CLI executable
        ".git"             # Git repository (for updates)
        ".gitignore"       # Git ignore patterns
        ".version"         # Version file
        "LICENSE"          # Legal requirement
        "README.md"        # Documentation
        "install.sh"       # Installation script
        "docs"             # Documentation directory
        "static"           # Static assets (logo, etc.)
        ".context"         # User context files
    )

    local found_aliens=()

    # Check all top-level files/directories
    for item in "$INSTALL_DIR"/{*,.[!.]*}; do
        # Skip if doesn't exist (glob didn't match)
        [ -e "$item" ] || continue

        local basename=$(basename "$item")
        local is_essential=false

        # Check if this item is essential
        for essential in "${essential_patterns[@]}"; do
            if [ "$basename" = "$essential" ]; then
                is_essential=true
                break
            fi
        done

        # Check if this item was previously deleted
        local was_deleted=false
        for deleted in "${deleted_aliens[@]}"; do
            if [ "$basename" = "$deleted" ]; then
                was_deleted=true
                break
            fi
        done

        # If not essential and not previously deleted, it's a new alien
        if [ "$is_essential" = false ] && [ "$was_deleted" = false ]; then
            found_aliens+=("$basename")
        fi
    done

    # If no alien files found, exit
    if [ ${#found_aliens[@]} -eq 0 ]; then
        return 0
    fi

    # Display found alien files
    echo -e "${YELLOW}⚠ Found unrelated files in your PromptStash installation:${NC}"
    echo ""
    for alien in "${found_aliens[@]}"; do
        echo -e "  ${YELLOW}•${NC} $alien"
    done
    echo ""
    echo "These files are not part of a standard PromptStash installation."
    echo "They may have been added manually or left over from a development setup."
    echo ""

    # Ask user what to do
    while true; do
        echo -e "${BLUE}Delete these files?${NC}"
        echo "  1) Yes - Delete now"
        echo "  2) No - Keep them for now"
        echo "  3) Never ask again"
        echo ""
        read -p "Your choice (1/2/3): " choice

        case "$choice" in
            1|yes|y|Y)
                echo ""
                echo -e "${BLUE}Removing unnecessary files...${NC}"
                for alien in "${found_aliens[@]}"; do
                    local full_path="$INSTALL_DIR/$alien"
                    if rm -rf "$full_path" 2>/dev/null; then
                        echo -e "  ${GREEN}✓${NC} Removed $alien"
                        # Remember this deletion (with lock to prevent race conditions)
                        local lock_file="$deleted_file.lock"
                        local timeout=100  # 100 iterations * 0.1s = 10 seconds
                        local waited=0

                        # Setup trap to cleanup lock file on exit
                        trap 'rm -f "$lock_file"' EXIT INT TERM

                        # Wait for lock (with timeout)
                        while [ -f "$lock_file" ] && [ $waited -lt $timeout ]; do
                            sleep 0.1
                            waited=$((waited + 1))
                        done

                        # Acquire lock
                        touch "$lock_file"
                        # Append deletion only if not already recorded (prevent duplicates)
                        if ! grep -Fxq "$alien" "$deleted_file" 2>/dev/null; then
                            echo "$alien" >> "$deleted_file"
                        fi
                        # Release lock
                        rm -f "$lock_file"
                        trap - EXIT INT TERM

                        # Untrack from git if it was tracked
                        if [ -d "$INSTALL_DIR/.git" ]; then
                            cd "$INSTALL_DIR"
                            git rm -r --cached --ignore-unmatch "$alien" &>/dev/null || true
                        fi
                    else
                        echo -e "  ${RED}✗${NC} Failed to remove $alien"
                    fi
                done
                echo ""
                echo -e "${GREEN}✓ Cleanup complete!${NC}"
                break
                ;;
            2|no|n|N)
                echo ""
                echo -e "${YELLOW}Keeping files. Run 'promptstash cleanup' to check again later.${NC}"
                break
                ;;
            3|never)
                echo "never" > "$config_file"
                echo ""
                echo -e "${GREEN}✓ Won't ask again. To re-enable, delete: $config_file${NC}"
                break
                ;;
            *)
                echo -e "${RED}Invalid choice. Please enter 1, 2, or 3.${NC}"
                echo ""
                ;;
        esac
    done
}

# List all prompts (non-interactive)
list_prompts() {
    local prompts_dir="$INSTALL_DIR/.promptstash"

    if [ ! -d "$prompts_dir" ]; then
        echo -e "${RED}✗ Error: Prompts directory not found: $prompts_dir${NC}"
        exit 1
    fi

    # Get all .md files and sort them alphabetically
    local prompts=()
    while IFS= read -r prompt; do
        prompts+=("$prompt")
    done < <(find "$prompts_dir" -maxdepth 1 -name "*.md" -type f -exec basename {} \; | sort)

    if [ ${#prompts[@]} -eq 0 ]; then
        echo -e "${YELLOW}No prompts found in $prompts_dir${NC}"
        return 0
    fi

    # Display prompts in alphanumeric order
    for prompt in "${prompts[@]}"; do
        echo "$prompt"
    done
}

# Pick a prompt interactively
pick_prompts() {
    local mode="$1"
    local prompts_dir="$INSTALL_DIR/.promptstash"

    if [ ! -d "$prompts_dir" ]; then
        echo -e "${RED}✗ Error: Prompts directory not found: $prompts_dir${NC}"
        exit 1
    fi

    # Get all .md files and sort them alphabetically
    local prompts=()
    while IFS= read -r prompt; do
        prompts+=("$prompt")
    done < <(find "$prompts_dir" -maxdepth 1 -name "*.md" -type f -exec basename {} \; | sort)

    if [ ${#prompts[@]} -eq 0 ]; then
        echo -e "${YELLOW}No prompts found in $prompts_dir${NC}"
        exit 1
    fi

    # Detect clipboard command (use array for proper handling of multi-word commands)
    local -a clipboard_cmd=()
    if command -v pbcopy &> /dev/null; then
        clipboard_cmd=("pbcopy")
    elif command -v xclip &> /dev/null; then
        clipboard_cmd=("xclip" "-selection" "clipboard")
    elif command -v wl-copy &> /dev/null; then
        clipboard_cmd=("wl-copy")
    else
        echo -e "${RED}✗ Error: No clipboard command found${NC}"
        echo ""
        echo "The pick command requires a clipboard utility. Please install one:"
        echo ""
        echo "  macOS:        pbcopy (pre-installed)"
        echo "  Linux (X11):  sudo apt install xclip"
        echo "  Linux (Wayland): sudo apt install wl-clipboard"
        echo ""
        exit 1
    fi

    # Display numbered list
    echo -e "${BLUE}Available prompts:${NC}"
    echo ""
    local index=1
    for prompt in "${prompts[@]}"; do
        printf "%d - %s\n" "$index" "$prompt"
        index=$((index + 1))
    done
    echo ""

    # Interactive loop for user input
    while true; do
        read -p "Select a prompt number (or 'q' to quit): " choice

        # Check if user wants to quit
        if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
            echo "Cancelled."
            exit 0
        fi

        # Validate input is a number
        if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}✗ Error: Invalid input. Please enter a number.${NC}"
            continue
        fi

        # Validate number is in range
        if [ "$choice" -lt 1 ] || [ "$choice" -gt ${#prompts[@]} ]; then
            echo -e "${RED}✗ Error: Invalid selection. Please choose a number between 1 and ${#prompts[@]}.${NC}"
            continue
        fi

        # Get selected prompt (arrays are 0-indexed)
        local selected_prompt="${prompts[$((choice - 1))]}"
        local prompt_path="$prompts_dir/$selected_prompt"

        # Copy to clipboard using helper function
        copy_to_clipboard "$mode" "$selected_prompt" "$prompt_path" "${clipboard_cmd[@]}"

        # Successfully copied, exit the loop
        break
    done
}

# Copy to clipboard based on mode
# Args: mode, selected_prompt_name, prompt_path, clipboard_cmd_array
copy_to_clipboard() {
    local mode="$1"
    local selected_prompt="$2"
    local prompt_path="$3"
    shift 3
    local -a clipboard_cmd=("$@")

    case "$mode" in
        name)
            if echo -n "$selected_prompt" | "${clipboard_cmd[@]}" 2>/dev/null; then
                echo -e "${GREEN}✓ Saved to clipboard: $selected_prompt${NC}"
            else
                echo -e "${RED}✗ Error: Failed to copy to clipboard: $selected_prompt${NC}"
                echo "The clipboard command (${clipboard_cmd[*]}) failed. Please ensure it's properly configured."
                exit 1
            fi
            ;;
        content)
            if cat "$prompt_path" | "${clipboard_cmd[@]}" 2>/dev/null; then
                echo -e "${GREEN}✓ Saved to clipboard: contents of $selected_prompt${NC}"
            else
                echo -e "${RED}✗ Error: Failed to copy to clipboard: contents of $selected_prompt${NC}"
                echo "The clipboard command (${clipboard_cmd[*]}) failed. Please ensure it's properly configured."
                exit 1
            fi
            ;;
        path)
            if echo -n "$prompt_path" | "${clipboard_cmd[@]}" 2>/dev/null; then
                echo -e "${GREEN}✓ Saved to clipboard: $prompt_path${NC}"
            else
                echo -e "${RED}✗ Error: Failed to copy to clipboard: $prompt_path${NC}"
                echo "The clipboard command (${clipboard_cmd[*]}) failed. Please ensure it's properly configured."
                exit 1
            fi
            ;;
        *)
            echo -e "${RED}✗ Error: Unknown mode: $mode${NC}"
            exit 1
            ;;
    esac
}

# Show search usage helper
show_search_usage() {
    echo -e "${RED}✗ Error: search command requires a query${NC}"
    echo ""
    echo "Usage: promptstash search [name|content|path] <query>"
    echo ""
    echo "  search <query>          - List matching prompts (non-interactive)"
    echo "  search name <query>     - Pick from matches and copy filename"
    echo "  search content <query>  - Pick from matches and copy file contents"
    echo "  search path <query>     - Pick from matches and copy file path"
    exit 1
}

# Search prompts by filename and/or content
search_prompts() {
    local mode="$1"
    local query="$2"
    local prompts_dir="$INSTALL_DIR/.promptstash"

    if [ ! -d "$prompts_dir" ]; then
        echo -e "${RED}✗ Error: Prompts directory not found: $prompts_dir${NC}"
        exit 1
    fi

    if [ -z "$query" ]; then
        show_search_usage
    fi

    # Detect color support (check if terminal supports colors)
    local color_flag="never"
    if [ -t 1 ] && command -v tput &>/dev/null && [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ]; then
        color_flag="always"
    fi

    # Store matches: filename, matching line (for display)
    local -a match_files=()
    local -a match_contexts=()

    # Search through all .md files
    while IFS= read -r filepath; do
        local filename="${filepath##*/}"
        local found_match=false
        local match_context=""

        # Check if filename matches (case-insensitive, literal string)
        if echo "$filename" | grep -Fiq "$query"; then
            found_match=true
            # Highlight match in filename using grep color (portable approach)
            # Use GREP_COLORS to set bold red for matches
            match_context=$(echo "$filename" | GREP_COLORS='ms=01;31' grep -Fi --color="$color_flag" "$query" || echo "$filename")
        fi

        # Search file contents (case-insensitive, literal string)
        if grep -Fiq "$query" "$filepath"; then
            found_match=true
            # Get first matching line with context and highlight using grep color
            local matching_line=$(GREP_COLORS='ms=01;31' grep -Fi -m 1 --color="$color_flag" "$query" "$filepath" | sed 's/^[[:space:]]*//' | cut -c1-100)
            if [ -n "$matching_line" ]; then
                if [ -z "$match_context" ]; then
                    match_context="$matching_line"
                else
                    match_context="$match_context"$'\n'"  $matching_line"
                fi
            fi
        fi

        if [ "$found_match" = true ]; then
            match_files+=("$filename")
            match_contexts+=("$match_context")
        fi
    done < <(find "$prompts_dir" -maxdepth 1 -name "*.md" -type f | sort)

    # Check if prompts directory has any .md files
    if [ ${#match_files[@]} -eq 0 ]; then
        # Check if directory is empty
        local file_count=$(find "$prompts_dir" -maxdepth 1 -name "*.md" -type f | wc -l)
        if [ "$file_count" -eq 0 ]; then
            echo -e "${RED}✗ Error: No .md files found in prompts directory: $prompts_dir${NC}"
            exit 1
        fi
    fi

    # Check if any matches found
    if [ ${#match_files[@]} -eq 0 ]; then
        echo "No matches found in file names or file contents for \`$query\`."
        exit 0
    fi

    # Non-interactive mode: just list matches
    if [ "$mode" = "list" ]; then
        for i in "${!match_files[@]}"; do
            echo "- \`${match_files[$i]}\`"
            if [ -n "${match_contexts[$i]}" ]; then
                echo "  ${match_contexts[$i]}"
            fi
        done
        return 0
    fi

    # Interactive mode: numbered list
    # Detect clipboard command (use array for proper handling of multi-word commands)
    local -a clipboard_cmd=()
    if command -v pbcopy &> /dev/null; then
        clipboard_cmd=("pbcopy")
    elif command -v xclip &> /dev/null; then
        clipboard_cmd=("xclip" "-selection" "clipboard")
    elif command -v wl-copy &> /dev/null; then
        clipboard_cmd=("wl-copy")
    else
        echo -e "${RED}✗ Error: No clipboard command found${NC}"
        echo ""
        echo "The search command with name/content/path requires a clipboard utility. Please install one:"
        echo ""
        echo "  macOS:        pbcopy (pre-installed)"
        echo "  Linux (X11):  sudo apt install xclip"
        echo "  Linux (Wayland): sudo apt install wl-clipboard"
        echo ""
        exit 1
    fi

    # Display numbered matches
    echo ""
    for i in "${!match_files[@]}"; do
        local num=$((i + 1))
        echo "$num - \`${match_files[$i]}\`"
        if [ -n "${match_contexts[$i]}" ]; then
            echo "  ${match_contexts[$i]}"
        fi
    done
    echo ""

    # Prompt for selection
    while true; do
        read -p "Please select a prompt number to copy to clipboard (or 'q' to quit): " choice

        # Check if user wants to quit
        if [ "$choice" = "q" ] || [ "$choice" = "Q" ]; then
            echo "Cancelled."
            exit 0
        fi

        # Validate input is a number
        if ! [[ "$choice" =~ ^[0-9]+$ ]]; then
            echo -e "${RED}✗ Error: Invalid input. Please enter a number.${NC}"
            continue
        fi

        # Validate number is in range
        if [ "$choice" -lt 1 ] || [ "$choice" -gt ${#match_files[@]} ]; then
            echo -e "${RED}✗ Error: Invalid selection. Please choose a number between 1 and ${#match_files[@]}.${NC}"
            continue
        fi

        # Get selected prompt (arrays are 0-indexed)
        local selected_prompt="${match_files[$((choice - 1))]}"
        local prompt_path="$prompts_dir/$selected_prompt"

        # Copy to clipboard using helper function
        copy_to_clipboard "$mode" "$selected_prompt" "$prompt_path" "${clipboard_cmd[@]}"

        # Successfully copied, exit the loop
        break
    done
}

# Show help
show_help() {
    cat << EOF
PromptStash CLI - A collection of generic, reusable developer prompts

Usage: promptstash [command]

Commands:
  list             List all available prompts (non-interactive)
  pick name        Interactive prompt picker - copies filename to clipboard
  pick content     Interactive prompt picker - copies file contents to clipboard
  pick path        Interactive prompt picker - copies absolute path to clipboard
  search <query>           Search prompts and list matches (non-interactive)
  search name <query>      Search prompts and pick - copies filename to clipboard
  search content <query>   Search prompts and pick - copies file contents to clipboard
  search path <query>      Search prompts and pick - copies absolute path to clipboard
  self-update      Update PromptStash to the latest version
  cleanup          Check for and remove unnecessary files
  version          Show the current version
  help             Show this help message

Environment Variables:
  PROMPTSTASH_DIR              Path to the prompts directory
  PROMPTSTASH_NO_UPDATE_CHECK  Set to '1' to disable update checks

Examples:
  promptstash list                # List all prompts
  promptstash pick content        # Interactive picker
  promptstash search commit       # Search and list matches
  promptstash search name debug   # Search and pick interactively
  promptstash self-update         # Update to latest version

Prompts are located in: \$PROMPTSTASH_DIR
Learn more: https://github.com/korotkevics/promptstash
EOF
}

# Main command handler
main() {
    case "$1" in
        list)
            list_prompts
            ;;
        pick)
            # Pick command requires a subcommand
            case "$2" in
                name|content|path)
                    pick_prompts "$2"
                    ;;
                "")
                    echo -e "${RED}✗ Error: pick command requires a subcommand${NC}"
                    echo ""
                    echo "Usage: promptstash pick [name|content|path]"
                    echo ""
                    echo "  name     - Copy filename to clipboard"
                    echo "  content  - Copy file contents to clipboard"
                    echo "  path     - Copy absolute path to clipboard"
                    exit 1
                    ;;
                *)
                    echo -e "${RED}✗ Unknown pick subcommand: $2${NC}"
                    echo ""
                    echo "Usage: promptstash pick [name|content|path]"
                    exit 1
                    ;;
            esac
            ;;
        search)
            # Search command can be used with or without a mode
            case "$2" in
                name|content|path)
                    # Interactive search with mode
                    search_prompts "$2" "$3"
                    ;;
                "")
                    # No query provided
                    show_search_usage
                    ;;
                *)
                    # Non-interactive search (query provided directly)
                    search_prompts "list" "$2"
                    ;;
            esac
            ;;
        self-update)
            self_update
            ;;
        cleanup)
            check_alien_files
            ;;
        version)
            show_version
            ;;
        help|--help|-h|"")
            show_help
            ;;
        *)
            # Unknown command - show error without update check
            echo -e "${RED}Unknown command: $1${NC}"
            echo ""
            show_help
            exit 1
            ;;
    esac

    # Check for updates after successful command (helps keep terminal clean)
    check_for_updates
}

main "$@"
